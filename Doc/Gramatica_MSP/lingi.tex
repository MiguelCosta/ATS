\documentclass[a4paper]{article}
\usepackage[portuguese]{babel}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{graphicx}
\usepackage{float}
\usepackage[affil-it]{authblk}
\usepackage{indentfirst}

\usepackage{titlesec}

\usepackage{aeguill}  % usefull for pdflatex
\usepackage[compat2,a4paper,twosideshift=0mm,left=20mm,right=20mm,bottom=20mm,top=15mm]{geometry}

\parindent=2em

\usepackage{xcolor}
\usepackage{listings}


\lstdefinestyle{gramatica}{
	backgroundcolor=\color{yellow!7},%
    numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt,% 
    basicstyle=\small\ttfamily\color{blue},%
    breaklines=true,%                                      allow line breaks
    moredelim=[s][\color{green!50!black}\ttfamily]{'}{'},% single quotes in green
    moredelim=*[s][\color{black}\ttfamily]{options}{\}},%  options in black (until trailing })
    commentstyle={\color{gray}\itshape},%                  gray italics for comments
    morecomment=[l]{//},%                                  define // comment
    emph={%
        STRING%                                            literal strings listed here
        },emphstyle={\color{blue}\ttfamily},%              and formatted in blue
    alsoletter={:,|,;},%
    morekeywords={:,|,;},%                                 define the special characters
    keywordstyle={\color{black}},%                         and format them in black
}

\definecolor{javared}{rgb}{0.6,0,0} % for strings
\definecolor{javagreen}{rgb}{0.25,0.5,0.35} % comments
\definecolor{javapurple}{rgb}{0.5,0,0.35} % keywords
\definecolor{javadocblue}{rgb}{0.25,0.35,0.75} % javadoc

\lstset{language=Java,
basicstyle=\ttfamily,
keywordstyle=\color{javapurple}\bfseries,
stringstyle=\color{javared},
commentstyle=\color{javadocblue},
morecomment=[s][\color{javadocblue}]{/**}{*/},
numbers=left,
numberstyle=\tiny\color{black},
stepnumber=1,
numbersep=10pt,
tabsize=4,
showspaces=false,
showstringspaces=false,
breaklines=true}



\title{Linguagem i--}
\author{Hugo Frade%
\thanks{Email: \texttt{hugoecfrade@gmail.com}}}
 
\author{Miguel Costa%
\thanks{Email: \texttt{miguelpintodacosta@gmail.com}}}

\author{Milton Nunes%
\thanks{Email: \texttt{milton.nunes52@gmail.com}}}
 
\affil{Análise e Transformação de Software,\\ UCE30 Análise e Concepção de Software,
\\ Mestrado em Engenharia Informatica,\\Universidade do Minho}
 
\date{\today}


\begin{document}
 
 
\maketitle
 
\begin{abstract}
Este documento apresenta a resolução do Trabalho Prático de Análise e Transformação de Software em que se definiu a linguagem i--, usando o AnTLR criou-se um compilador de forma a gerar código MSP.
\end{abstract}
 
 
\newpage
 
\parskip=0mm
\tableofcontents
\parskip=2mm
 
\newpage

\section{Introdução}
Tal como em maior parte das coisas no nosso dia à dia, as linguagens possuem uma hierarquia. No topo (0), encontra-se a linguagem natural, a mais difícil de decifrar devido à maior diversidade de termos e expressões que pudemos usar. Na base (3) encontram-se as linguagem regulares, que possuem um número muito limitado de termos, e por isso são bastante fáceis de descodificar e perceber.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{inputs/Hierarquia.png}
% imag2.png: 688x477 pixel, 72dpi, 24.27x16.83 cm, bb=0 0 688 477
\end{figure}

Formalmente uma gramática independente do contexto é definida como uma gramática formal\footnote{Objecto matemático que permite criação de linguagens através de um conjunto de regras de formação.} por regras de produção da formalmente definidas como:\verb|X -> x|, onde X é um símbolo não terminal e x é uma sequência de não terminais, ou até mesmo o vazio.

Depois de definida a gramática precisamos de um parser para o identificar. Como tal foi utilizado o AnTLR para criar esse parser. O AnTLR é uma ferramenta de reconhecimento de linguagem. Este aceita como input uma gramática que especifica a linguagem e gera o código fonte para o reconhecimento da linguagem. O AnTLR utiliza o algoritmo LL(*), algoritmo classificado como top-down.

Quando se escrever um programa, o objetivo é que ele faça alguma tarefa automaticamente, para tentar simular essa execução, nesta fase usamos uma máquina virutal com o nome MSP (Mais Simples Possível)

\section{Ambiente de Trabalho}
Foi necessário usar um Gerador de Compiladores para gerar o nosso próprio compilador, por isso usamos o AnTLR que é também usado nas aulas. Para facilitar o processo de debugging durante a resolução do problema, usamos a ferramenta AnTLRWorks, que tem uma interface bastante agradável e simpática para ajudar a resolver problemas desta natureza.

Visto que era necessário gerar código para ser executado pelo MSP, foi utilizada a máquina virtual que o professor disponibilizou para testes.

\section{Descrição do problema}
O que é pretendido é usar a gramática criada nos trabalhos anteriores da disciplina e adaptar para gerar código para ser lido pela MSP.

Das várias formas possíveis de fazer isso, a utilizada foi adicionar instruções às produções da gramática para dar como output o código pretendido.

\section{MSP}

\subsection{Implementação}
Incluir a geração de código MSP na nossa linguagem foi apenas fazer instruções nas produções para imprimir no output, ou seja, basicamente criámos uma gramática tradutora.	

Neste momento só suporta uma única função e variáveis do tipo inteiro.

Usando a gramática que foi criada nos projetos anteriores, adicionamos as instruções a seguir para gerar MSP.

\subsubsection{Declarações}
As declarações devem ser feitas no ínicio da função e são traduzidas da seguinte forma:

\begin{verbatim}
declaracoes
    :    {System.out.println("MEMORIA DE DADOS");} declaracaoExpr+
    ;

declaracaoExpr
    :    declaracao';'
    ;

declaracao
    :    tipo ID	{System.out.println($ID.text + " " + i++ + " TAM 1");}
    ;

\end{verbatim}

Usando um exemplo, se tivermos declarado:
\begin{verbatim}
int in;
int y;
\end{verbatim}
Temos como output:
\begin{verbatim}
MEMORIA DE DADOS
    in 0 TAM 1
    y  1 TAM 1
\end{verbatim}


\subsubsection{Ler e Escrever}
Relativamente `as funç~oes de leitura e escrita que o MSP implementa foi simples traduzir:
\begin{verbatim}
ler :    LER '(' ID ')' 		{System.out.println("PSHA " + $ID.text + "\nIN\nSTORE");}
    ;	
	
escrever:    ESCREVER '(' ID ')'	{System.out.println("PSHA " + $ID.text + "\nLOAD\nOUT");}
    ;
\end{verbatim}

Se tivermos:
\begin{verbatim}
ler(in);
\end{verbatim}
Obtemos:
\begin{verbatim}
PSHA in
IN
STORE
\end{verbatim}

\subsubsection{if}
Para controlar a existência de vários if's na mesma função, usamos uma varáivel global \verb|fse| que indica o número do if no programa.
\begin{verbatim}
ifs :    IF '(' expr ')' {System.out.println("JMPF senao"+ ++senao);} 
         bloco {System.out.println("JMP fse"+ ++fse);} 
         ifsElse? {System.out.print("fse"+fse+": ");}
\end{verbatim}

Usando como exemplo de entrada:
\begin{verbatim}
if(in > 10){
    escrever(in);
}else{
    escrever(y);
}
\end{verbatim}

Temos como output MSP:

\begin{verbatim}
PSHA in
LOAD
PUSH 10
GT
JMPF senao1
PSHA in
LOAD
OUT
JMP fse1
\end{verbatim}

\subsubsection{Operadores}
Para usar nas condições dos if's e dos while's, é necessário converter os operadores lógicos e matemáticos. Isso é feito da seguinte forma:
\begin{verbatim}
orExprAux:    opOr andExpr		{System.out.println("OR");}
    ;

andExpr	:    equalExpr andExprAux*
    ;

andExprAux: opAnd equalExpr    {System.out.println("AND");}
    ;

equalExpr
    :    addExpr equalExprAux*	
    ;
	
equalExprAux: opRel addExpr    
                    {if($opRel.text.equals("==")) System.out.println("EQ");
                    if($opRel.text.equals(">")) System.out.println("GT");
                    if($opRel.text.equals(">=")) System.out.println("GE");
                    if($opRel.text.equals("<")) System.out.println("LT");
                    if($opRel.text.equals("<=")) System.out.println("LE");
                    if($opRel.text.equals("!=")) System.out.println("NE");}
    ;	
	
addExpr :    multExpr addExprAux*
    ;

addExprAux: opAdd multExpr
    ;
	
multExpr:	notExpr multExprAux*
    ;

multExprAux: opMul notExpr		{if($opMul.text.equals("/")) System.out.println("DIV");
                    if($opMul.text.equals("*")) System.out.println("MUL");
                    if($opMul.text.equals("\%")) System.out.println("MOD");}
    ;

\end{verbatim}

\subsection{Exemplo}
O seguinte exemplo na lingagem i--:
\begin{verbatim}
int main(){
    int in;
    int y;

    ler(in);

    y = 0;

    if(in > 10){
        escrever(in);
    }else{
        escrever(y);
    }
    return 0;
}
\end{verbatim}

Gera o seguinte código MSP:
\begin{verbatim}
MEMORIA DE DADOS
    in 0 TAM 1
    y 1 TAM 1
CODIGO
    PSHA in
    IN
    STORE
    PSHA y
    PUSH 0
    STORE
    PSHA in
    LOAD
    PUSH 10
    GT
    JMPF senao1
    PSHA in
    LOAD
    OUT
    JMP fse1
senao1: PSHA y
    LOAD
    OUT
fse1: PUSH 0
    HALT
\end{verbatim}


\section{Conclusões}

A resolução deste exercício permitiu perceber melhor a forma como as linguagens podem ser úteis para gerar um programa, que dependendo do input que irá receber, o resultado final seja o esperado sem ter de estar a alterar o código do programa que é automaticamente gerado. Apesar de não termos qualquer tipo de output, as árvores geradas permitiram chegar a estas conclusões.

A dificuldade neste trabalho foi encontrar a melhor forma de traduzir a linguagem i-- em código para correr na máquina virtual MSP.

\end{document}
